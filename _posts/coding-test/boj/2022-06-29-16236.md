---

title:  "[백준 16236] 아기 상어"

categories:
  - BOJ
tags:
  - [Java, Coding Test, BFS, Priority Queue]

toc: true
toc_sticky: true

date: 2022-06-29
last_modified_at: 2022-06-29
---


## 난이도

> Gold 3

## 문제

> [https://www.acmicpc.net/problem/16236](https://www.acmicpc.net/problem/16236)

## 풀이



```java
import java.io.*;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {
  	// 상어 클래스
    static class Fish implements Comparable<Fish> {
        int r, c, depth, size, cnt;

        public Fish(int r, int c, int depth, int size, int cnt) {
            this.r = r;
            this.c = c;
            this.depth = depth;
            this.size = size;
            this.cnt = cnt;
        }

        public void eat() {
          	// 상어가 물고기를 먹었고 (++cnt)
           	// 이 때, 자기 크기 만큼의 물고기를 먹었으면
            if (++cnt == size) {
                size++; // 상어 성장
                cnt = 0; // 먹은 횟수 초기화
            }
					
            answer += depth; // 물고기를 먹으러 가는데 걸린 이동 횟수 만큼 정답에 반영
            map[r][c] = 0; // 물고기 먹은 위치 빈공간 처리
            depth = 0; // 다음 물고기 먹으러 가야하니 이동 횟수 초기화 (pq 우선 순위 앞으로)
        }
				
      	// 정렬 우선 순위
      	// 깊이, 세로, 가로
      	// 전부 오름차순
        @Override
        public int compareTo(Fish f) {
            if (depth != f.depth) return depth - f.depth;
            if (r != f.r) return r - f.r;
            return c - f.c;
        }
    }

    static int N, answer; // 데이터 크기, 정답
    static int[][] map; // 데이터
  	// 상하좌우
    static int[] dr = {-1, 1, 0, 0};
    static int[] dc = {0, 0, -1, 1};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        map = new int[N][N];
        Fish shark = null; // 상어 초기 위치
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
              	// 입력 값이 상어면
                if (map[i][j] == 9) {
                    shark = new Fish(i, j, 0, 2, 0); // 상어 초기 위치 데이터 생성
                    map[i][j] = 0; // 상어가 있는 곳은 빈공간 처리
                }
            }
        }

        answer = 0;
        bfs(shark);

        bw.write(Integer.toString(answer));
        bw.close();
        br.close();
    }

    private static void bfs(Fish shark) {
        boolean[][] visited = new boolean[N][N]; // 방문 위치 확인
        visited[shark.r][shark.c] = true; // 상어 초기 위치 방문 처리
        PriorityQueue<Fish> pq = new PriorityQueue<>(); // 우선순위 큐
        pq.offer(shark); // 상어 초기 위치 데이터 입력

        while (!pq.isEmpty()) {
            shark = pq.poll(); // 하나 꺼내서
						
          	// 상어보다 큰 물고기가 있으면 못가니까 넘김
            if (map[shark.r][shark.c] > shark.size) continue;
          	// 상어가 먹을 수 있는 물고기가 있으면
            if (map[shark.r][shark.c] != 0 && shark.size > map[shark.r][shark.c]) {
                shark.eat(); // 물고기 먹음
                visited = new boolean[N][N]; // 방문 위치 초기화
                pq.clear(); // 상어 위치 초기화
            }
						
          	// 상어가 이동했다면 상하좌우 방문
            for (int d = 0; d < 4; d++) {
                int nr = shark.r + dr[d];
                int nc = shark.c + dc[d];
								
              	// 갈 수 있는지, 이미 방문했는지 확인
                if (!check(nr, nc) || visited[nr][nc]) continue;
                
              	// 갈 수 있으면
                visited[nr][nc] = true; // 방문 처리
	              // 상어 위치 데이터 추가 (단, 깊이(이동 횟수) + 1)
                pq.offer(new Fish(nr, nc, shark.depth + 1, shark.size, shark.cnt));
            }
        }
    }

    private static boolean check(int r, int c) {
        return r >= 0 && r < N && c >= 0 && c < N;
    }
}
```
